
В плюсах есть проблема с передачей указателя, если указатель ссылается на массив.

(это в пользу Seq)

Если нужен массив базовых классов, а передаётся указатель на массив производных,
его обход будет выполнен неверно:


struct A
{
	int a;
};

struct B: A
{
	int b;
};

void foo(A *array, size_t size)
{
	for(A* pa = array; size > 0; ++pa, --size)
	{
		// делаем что-то с элементом *pa
	}
}

void bar()
{
	B bb[100];
	foo(bb, 100);
}


Всё компилируется, а ошибка явная.

Использование Seq снимает проблему на корню.


struct A
{
	int a;
};

struct B: A
{
	int b;
};

void foo(const Seq<A> &array)
{
	for(Seq<A>::iterator pa = array.begin(); pa != array.end(); ++pa)
	{
		// делаем что-то с элементом *pa
	}
}

void bar()
{
	B bb[100];
	foo( Seq<B>(bb, 100) );
}


Несмотря на то, что мы сконструировали временный объект типа Seq<B>, он неявно преобразуется
в Seq<A>, который на самом деле будет перебирать элементы типа B.

Содержимое массива при этом не копируется, идёт обращение к исходным элементам.

