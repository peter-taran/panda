
Управление жизнью объектов.

Есть три основных ситуации, в которых мы передаём объект.


I. Передача объекта параметром

И другие временные ссылки на объект. На объект ссылаемся в контексте его объявления, по выходу из контекста объект нас перестаёт интересовать.

II. Возврат объекта

Объект возвращается из функции как результат и используется произвольным образом.

III. Сохранение объекта на потом

Переданный снаружи объект или ссылка на объект сохраняется в статической или динамической памяти для последующих обращений.

Не следует путать этот вариант с хранением нашего собственного объекта, нами сконструированного и нами поддерживаемого.


* * *

Возможны три способа передачи объекта:
  - копированием         T и const T
  - ссылкой              const T&
  - управляемой ссылкой  Ref<T> и Ref<const T>


* * *

Делим объекты на три категории:

1. CopyFreely - могут копироваться совершенно свободно, по необходимости.
2. CopyPossible - могут копироваться, но только по явному запросю юзера.
3. CopyImpossible - копирование невозможно.

В первом случае так же важна (условная)цена копирования. Сравнивать её нужно с ценой копирования ссылки.

1.а. Копирование не хуже копирования неуправляемой ссылки.
1.б. Копирование не хуже копирования управляемой ссылки.
1.в. Копирование дороже ссылок.

NB. Копирование управляемой ссылки всегда не лучще копирования неуправляемой.

SelfManaged object - объект, самостоятельно управляющий временем своей жизни. Управляемая ссылка на такой объект выступает как wrapper надо возможностями самого объекта.


* * *

Поэтому предпочтительный способ передачи объекта таков:

I.   Копирование для 1.а, неуправляемая ссылка для прочих случаев

II.  Копирование для 1.а, 1.б, управляемая ссылка для прочих случаев.

III. Копирование для 1.а, 1.б, управляемая ссылка для прочих случаев.


* * *

Важный нюанс. Даже если объект T допускает свободное копирование (как Int), всё равно в некоторых случаях он должен передаваться ссылкой - по явному требованию пользователя.

Это нужно для случая III, когда объект в будущем может изменить состояние, но смотреть мы хотим именно на этот изменившийся объект, а не на его копию.

TODO: надо разобраться, как в III мы будем различать эти случаи, если объект передан по управляемой ссылке.


* * *

Управляемая ссылка Ref.

Состоит из:
- указателя на объект
- указателя на виртуальную таблицу методов
- пользовательских данных фиксированного размера

Размер = 3-м указателям.

Возможен вариант, когда ссылки на объект не хранится, разыменование при этом идёт через косвенный вызов функции, что дольше, но компактней.

Возможет вариант, когда не хранится пользовательских данных, если они требуются, их придётся так или иначе вычислять из ссылки на объект.

Допускает безопасную передачу объекта для всех случаев, логика зашита в виртуальные функции.

Может владеть объектом (т.е. пока ссылка есть, объект существует), может не владеть (объект может быть уничтожен даже при наличии ссылки, эта ситуация может рассматриваться как ошибочная и как нормальная).

Владеющая ссылка может использоваться для II и III, невладеющие только для I.

const Ref<T> не может переназначаться на другой объект (переинициализироваться), Ref<T> может делать это.

Ref<T> всегда ссылается на объект. Nullable< Ref<T> > то же самое что Ref0<T> допускает null-значение.

Ref<T> свободно копируется в другие Ref<T>.

У Ref<T> T не является ссылкой. TODO: возможно, не является указателем, хотя технической необходимости в таком ограничении вроде нет. Разве что для исключения ошибок.

Ref<T> может неявно создаваться из:
- объектов типа 1, при этом создаётся копия объекта
- SelfManaged объектов, при этом используются собственные возможности объекта

Ref<T> может явно создаваться из объектов типа 2, при этом создаётся копия объекта.

Ref<T> не может создаваться из объектов типа 3, их нужно сразу или создавать под управлением или делать самоуправляемыми.


* * *

Управление жизнью объекта.

В Панде предусмотрены следующие способы сохранения объекта:

0. Явная

Ссылка с явно определённым пользователем поведением.

1. Scoped.

Уничтожается по выходу из объявленного контекста.

Хранит внутри себя счётчик ссылок, который считает число существующих Ref'ов на объект.

При уничтожении контролируется, чтобы Ref'ов не было. Это поведение отключается упоминанием Dontcheck.


2. Dynamic.

Динамический объект, уничтожаемый по явному запросу юзера.

Поведение аналогично Scoped.

3. RefCounted.

Объект со счётчиком ссылок (Ref'ов) внутри, уничтожается по достижению счётчиком нуля.

4. ScopedRet.

Специально для возвращаемых значений. Владение объектом передаётся первому Ref'у,
созданному на основе ScopedRet.

При уничтожении этого Ref'а, объект уничтожается так же.

TODO: крайне сомнительное поведение. А если тот, кто получил возврат решит сохранить объект
на будущее - как ему это сделать?

5. Static.

Статический объект, который живёт всё время работы программы.

Ссылки на него очень дешёвые и никак не контролируются.

6. Самонесущая ссылка

Ссылка, сохраняющая объект внутри и копирующая его при копировании ссылки.

