
В cppdragon нужные следующие фичи.

(альтернативное название C++Dragon - Humanistic C++, Kindness C++, etc)

Дракон не добр. Дракон не зол. Дракон это воплощение самой природы: могущественной и толковой. (...essence of nature: smart and powerful)

Поэтому Дракон - неплохой символ для инструментов, претендующих быть могущественными и толковыми. (so Dragon is a good symbol for tools, claiming to be smart and powerful)



1. Класс элементарной строки String (или Str)

Её можно заменить целиком, но по кускам  она не редактируется - как элементарные типы.

Может хранить строку внутри себя, а может быть оболочкой вокруг чужого хранилища.

Ну и кодировки символов внутри. Кодировки символов должны применяться и к отдельным символам


2. Класс Sequence (или Seq)

Интерфейс к неизменяемой последовательности. Т.е. сами значения менять можно,
а добавлять-удалять-двигать элементы - нет. Ну и целиком можно переприсваивать.

Короче, это типа контейнер - элементарное значение!

Это чтобы передавать массив значений куда угодно.

Как и строка, может хранить данные внутри себя, а может быть оболочкой над чем-то третьим.

Бонусы к стандартным контейнерам:
- Seq универсален; тот кто его получает не скован реализацией контейнера и не должен быть
  шаблоном
- Seq можно преобразовывать в Seq с другим типом элемента:
    Seq<T> -> Seq<const T>
    Seq<int> -> Seq<double>

Так же неплохо уметь генерировать виртуальные Seq'и на такие вещи как последовательность
чисел, например.

foreach(Uint i, range(0, 200)); // range возвращает Seq<Uint>

Неплохо бы набор алгоритмов над ним - чтобы не дебильной парой итераторов пользоваться,
а единым объектом. Но дублирование стандартного серьёзного смущает. Как минимум метод
filter или некий аналог нужен. min/max неплохо бы, с предикатом-параметром.

Ещё функция makeSeq(begIter, endIter). Seq<MyComplexClass>(begIter, endIter) - хуже.

Хочу отметить, что разницы между Seq<T&> и Seq<T> никакой нет. Соответственно, к типу надо
применять dereference. Или ещё тупее - запрещать Seq<T&>.

Нерешённый вопрос: как бы интегрировать в Seq (и Collection) текущий способ сортировки.
Указывать его каждый раз - верный путь к ошибкам. Но если мы вшиваем сортировку, надо
и оптимальный поиск делать - и отдельного элемента и интервала.


3. Оболочки над элементарными типами

Целые, вещественные, символы, логические.

Оболочка-класс. Инициализирует нулём, не допускает смешивания текстовых символов с байтами,
присваивания маленьких большим и т.п.

Причём оболочка связана не с int-short-long, а либо "оптимальный int", либо "int с заданным
количеством битов".

Char должен внутри себя хранить перекодировку. Char + Char = String (а не число!). Char
должен уметь неявно превращаться в строку.

optional<Bool> это тройная логика (да, нет, ХЗ). Должны поддерживаться операции.


4. Собственные элементарные типы

Нужна фича определения своих элементарных типов, несовместимых по присваиванию с другими.

Чтобы можно было им давать не все операции (типа поддерживать сложение или нет).

Это для тех случаев, когда int не целое число, а какой-нибудь там идентификатор.

Так же нужны ranged-целые, с заданым минимумом и максимумом. С ними, правда, не вполне
понятно, как строить арифметику - неплохо бы задавать, допустима ли арифметика и если да,
то какая? Циклическая? С насыщением (больше максимума = максимум)? С ошибкой при выходе
за границы?

optional<T> тоже должен поддерживать арифметику и вместо исключения становиться null'ом.


5. Умные enum'ы.

См. http://rsdn.ru/article/cpp/Cpp_Strict_Enumerations.xml


6. Класс Optional (nullable) и константа null (nothing)

Типа NULL в СУБД.

Можно рассматиривать как неинициализированность переменной. Семантика "значения нету".

optional<T> будем typedef'ить как T0.

optional<T&> ????

const optional<T> хранит const T ????

optional должен уметь взаимодействовать с типом, которые о нём знают. Должна быть возможность
определить частичную специализацию, чтобы операции и методы поддерживались и на optional-варианте.
Без специализации возможны три стратегии:
- optional-фичи реализуются внутри класса-хозяина
- выделяется память под класс и рядом - Bool с признаком инициализированности
- хранится указатель на динамический класс, нулевое значение которого - null


7. Сравнение с несколькими

x == oneof(a, b, c)
x != oneof(a, b, c)


8. Addr (Memaddr, Mem, Pointer)

Умная оболочка над void*.

Должен уметь молча инициализироваться из void*, const void*. const void* const, void* const.


9. Смещение в памяти

Если Index не делаем, нужен спец.класс Mem (или по-другому названный), который хранит
размеры и смещения в памяти. Арифметика циклическая: если это смещение, то сложением
с Addr мы можем перескочить границу памяти и уйти на младшие адреса.

Если это размер или счётчик, то он всегда рассматривается как положительный.

При преобразовании в строку и обратно для отображения отрицательных смещений надо
указывать особый спецификатор.


10. Форматирование строк

Класс, заж0вывающий форматную строку и параметры

fmt("xxxx") % a % b % c;

или 

fmt f("xxxx");
f %= a;
f %= b;
Str x = f;

Постепенное задание параметров, именованные параметры, расширяемость юзерскими типами.

Разумеется, типобезопасность. Бустовский format уж очень тяжеловесный и громоздкий
в использовании.


11. Универсальная функция преобразования в строку.

Не надо в каждый класс лепить метод преобразования. Лучше, на мой взгляд, сделать
функцию toStr, для которой, с появлением новых классов будут дописываться версии.

У неё должен быть второй аргумент - форматная строка.

Str toStr(const T &t, Str0 format = null);

Не надо делать, 


12. Bigint

Целое число без ограничения диапазона.

Неплохо бы какое-нибудь ввинтить, может из буста.


13. Универсальный ноль zero

Очень популярны сравнения с нулём и инициализация из нуля. Есть два момента:

а. Нулевой указатель и числовой ноль неразличимы, поэтому класс, имеющий два
конструктора:
    T(void *)
    T(int)
порождает неоднозначность при вызове T(0) или T(NULL): void* или int выбрать?

б. Если преобразование из числа к T явное (см. UMem, например), сравнения
с нулём очень громоздки:
    T x;
    if( x > T(0) )
вместо этого мы вводим универсальную константу zero особого типа Zero, которая
снимает все неоднозначности.

а.  T(void *)
    T(int)
    T(Zero)

    T(zero)

б.  if( x > zero )

Критика

а. Во-первых, случай сам по себе редкий и нередко говорящий о дурной архитектуре.
Во-вторых, с нашими элементарными типами Str, Pointer, Int и пр., которые заменят
слишком общие стандартные — станет ещё более редким.

Поэтому здесь zero просто не нужен.

б. Для этого нужно неявное преобразование zero к куче разных типов. А такие неявные
преобразования - зло, от которых мы уходим. Можно наловить сложных ошибок.

Например:
    T(A);
    T(B);

    T(0) - ошибка, укажите A или B
    T(zero) - нормально, если только один из A и B инициализируется из zero

т.е. получаем разное поведение, причём второе вполне вероятно ошибочно. Юзер же
не всегда думает про преобразования. У него в голове будет алгоритм «не сожрал 0,
попробуй zero, закомпилировалось, значит порядок».

Здесь выход - двойная арифметика. Если есть бинарные операции T.T и T
умеет явно (explicit) инициализироваться из R, то надо ввести бинарные
операции T.R.

Для операций T1.T2 надо ввести два доп.комплекта: R.T2, T1.R.
(к обычным методам это не относится).

Тогда будет работать самый простой и естественный if( x > 0 )


14. Изменяемая строка (StringBuilder, MutableString)

Всегда хранит данные внутри себя, заточена под всякие манипуляции с содержимым.

Реализация может меняться прямо на лету, т.е. вся работа - ч.з. виртуальные функции.

Но желаемую реализацию неплохо бы уметь подсказывать в конструкторе спец.параметром.


15. Изменяемый контейнер (Collection)

Универсальный последовательный контейнер, единая замена для vector, list, deque, stack
и подобных. На виртуальных функциях.

Реализация задаётся параметрами конструктора. Плюс в том, что реализацию нет нужды
помнить потом, работа строго одинаковая с любой реализацией. Но при создании
надо сделать выбор.

Можно потребовать переключиться на указатели, если копирование предполагается
затратным. Абстрактный тип может быть элементом коллекции, тогда всегда указатели.

Т.е. Collection<TTT><collVector, collPointers, collCapacity<8> >() создаёт вектор,
хранящий указатели на TTT с начальным количеством 8. А работаешь ты с ним, как с
коллекцией TTT, не думая более ни о чём!

Техника "владеющей коллекции". Когда ты объявляешь коллекцию Coll<T>. А совать можешь
указатель, указывая спец.синтаксисом, что передаёшь владение объектом коллекции.
Тут надо предусмотреть интеграцию со scoped_ptr. Хранение может быть и указателем и
объектом.

T* p = new T(100);
coll << ownership(p); // удалится через delete p
coll << ownership(p, &deleter); // с указанием функции-удалятора

Можно, конечно, безо всяких уточнений: Collection<TTT>()

template<class Item>
struct Vector
{
	template<class usePointers, class startCapacity>
	Vector();
};


struct collVector
{
    template
    <
        class Item, 
        class P1 = Uninitialized,
        class P2 = Uninitialized,
        class P3 = Uninitialized,
        class P4 = Uninitialized
    >
    Collection<Item>* create(const optional< Seq<Item> >& from)
    {
        return new Vector<Item>
        <
            extractOnOf<P1, P2, P3, P4, collPointers, collNoPointers>::type,
            extractCapacity<P1, P2, P3, P4>::type
        >
        (from);
    }
};

Неплохо бы нашим уметь делать разные типы итераторов:
- которые учитывались бы коллекцией и инвалидились реально при изменениях
  (медленнее, прожорливее, но безопаснее)
- которые не учитывались бы контейнером и обращение по покривевшим итераторам
  была бы на совести юзера (быстрее, меньше жрёт памяти, но критично к ошибкам)
- при получении итераторов - рантайм-блокировка до их гибели

В любом случае полностью безопасно не получится, ибо есть реальные ссылки на
элементы, а элементы могут переехать в памяти. Альтернатива - умная ссылка.


16. Хитрые операции со строками:

а. Объединение строк ч/з разделители с игнорированием пустых строк:

Str join(const Str &separator, Seq<const Str> &strs);

join(", ", ("", "abc", "", "deg") -> "abc, deg"

StringBuilder::joinTo(const Str &separator, Seq<const Str> &strs);
    // после this добавляет разделитель, только если this непустой

б. Смещение (indentation)

Разбиение строки на подстроки и вставка в начало каждой из них заданного числа символов
(пробелов обычно). И обратная операция - удаление.

И спец. параметр - считать ли начало строки началом подстроки (по умолчанию - да).

в. Создание строки из повторяющихся подстрок


17. Умная ссылка

Ссылка-интерфейс, получающая объект ч/з виртуальную функцию. Даёт возможность перемещать обекты.

Подумать, надо ли. скорее всего в комплексе с умными указателями.


18. Классs Binary и BinaryStat

Для хранения нетипизированного буфера. Два варианта: со статическим и с динамическим
заданием размера.

Там нужна встроеная преобразовалка типов, которая по любому смещению позволит обратиться,
будто там лежит нужный тип.

Умеет преобразовываться в Seq<Byte>.

Нужен ли вариант Binary = оболочке над чужими данными? Не уверен. В принципе неплох. Но
и потребность не до конца ясна.

BinaryStat<8> b;
b.as<Int>(); // считаем, что Int в начале буфера
b.as<Int>(4); // считаем, что Int по смещению 4


19. TT со свойствами переменной (или типа) = Type Traits

template<class Class_>
struct TT
{
	typedef Class_ Class;
	TT(const Class&);

	static Umem size = Umem(sizeof(T));

	// сюда же trivialDestructor, equalComparable, clonable и пр.
	// сюда же можно динамические и статические кастования: statCaster, dynCaster, Bool trivialCast
};

Int x;
TT<Int>::size
TT(x)::size

typedef Ptr (*Caster)(Ptr from);
Caster caster = &TT<Int>::statCaster<Byte>; // преобразовалка Int -> Byte


20. Финализация

Чтобы можно было вызывать всякое по выходу из блока.

Есть boost::ScopeExit.
