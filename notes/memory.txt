
= Основные объекты

Менеджер памяти.
Глобальный менеджер памяти.
Куча.

Куча — объект, управляющий работой в одной области памяти. Он хозяин некоторого диапазона адресов.

Менеджер памяти владеет несколькими кучами, сам решает, из какой кучи выделить память, по необходимости создаёт и уничтожает кучи. Есть разные типы менеджеров, отличающиеся стратегиями работы с памятью.

Каждая куча может(?) рассматриваться как вырожденный менеджер.

Менеджеры при необходимости могут образовывать цепочки, т.е. владеть не только кучами, но и другими менеджерами.

Глобальный менеджер — он один, настраивается. Именно в него обращаются operator new и delete, т.ж. есть глобальные функции для тех, кто не хочет переопределять new/delete.

Глобальный менеджер есть общий, но с потоком может быть связан свой собственный. Т.е. new/delete одного потока обращаются к разным объектам.

Пользователь может создавать собственные менеджеры и кучи, интегрируюя их с уже имеющимися.

= Представление менеджеров

Менеджер/куча представляется обычным классом C++ с реализацией в приватной области без виртуальных функций и каких бы то ни было средств управления жизненным циклом.

Существуют абстрактный интерфейс, представляющий уже созданный менеджер. В нём и функция удаления менеджера.

И, наконец, существует обёртка (шаблон со специализациями), обёртывающий менеджер в абстрактный интерфейс.

Непосредственное использование менеджера и кучи — наиболее скоростное и удобное. Абстрактные интерфейсы удобны для универсальных менеджеров (а глобальный менеджер обычно универсален).

Ещё нужна обёртка, превращающая менеджер в std::allocator. Правда, не факт, что это возможно. Но хочется.

= Жизнь менеджера

Каждый менеджер может быть под пользовательским и под библиотечным управлением.

При пользовательском управлении юзер сам решает, когда ему жить и когда умирать — как с обычным объектом.

У пользовательского менеджера есть параметры смерти, определяющие, что делать, если при смерти не вся память освобождена:

* перейти под библиотечное управление; объект уничтожается, но его состояние клонируется в объект, находящийся в глобальном управлении
** и уничтожить менеджер как только все блоки будут освобождены
** и передать менеджер под управление глобального менеджера, если это возможно; тогда память будет использоваться для глобальных выделений
* освободить память (чтобы обращения породили AV); при этом в менеджер делается спец.пометка, чтобы эти адреса не занимать возможно дольше
* уничтожить менеджер, регион памяти бросить навсегда

Отдельно задаётся, писать в лог о таких случаях или нет. Так же настраивается возникновение отладочного события.

Менеджеры в библиотечном управлении

Независимо от того, под каким управлением находится менеджер, его кучи регистрируются в глобальном реестре, чтобы глобальная операция освобождения памяти освобождала её всегда.

= Типы куч

Универсальная куча из цепочки блоков переменной длины со служебной информацией при каждом.

Массив блоков фиксированного размера. Для отладки хорошо, когда освобождённый блок максимально долго остаётся таковым.

Куча из одного блока с целым числом страниц, взятая у системы. Возможно, подогнанная по правому краю с защитой страницы.

Жадная куча, каждый блок — одна или несколько страниц, подогнанных по правому или левому краю, за ним (перед ним) — защитная страница. Для суровой отладки.

Последовательная куча. Занимает память нарастающим потоком, пока не дойдёт до конца. Повторно память не использует.

= Глобальный менеджер

Он может меняться на лету, поддерживается стек.

Глобальный менеджер не обязательно в библиотечном управлении! Может быть и в пользовательском.

= Контексты

Контексты работы программы переключаются динамически (такая фича есть, например, в POCO).

При переключении контекста можно:

* сменить глобальный менеджер
* при всех выделяемых блоках ставить контекстную метку — в кучах, которые это поддерживают

Контекст можно переключать при входе в те или иные области программы, чтобы при утечках памяти грубо локализовать область утечки.

При включении контекстов особо важно делать это последовательно — т.е. защитить все выходы и выходы некоторого модуля, библиотеки и т.п.

= Отладочная информация

При выделении блоков памяти можно включить сохранение стека с указанием путей.

Можно сохранять текущий контекст.

Можно сохранять временную метку (или две: для выделения и для освобождения), которая позволит понять, что было раньше и позже.

= Стратегии использования =

== Простейшая ==

Заменить глобальный менеджер на библиотечный, operator new/delete на наши и ни о чём больше не думать.

Возможно, попользовать профилировщик для подбора оптимальных параметров.

== Освободить память процедуры ==

Когда начинается некая (тяжёлая) процедура, она переключается на последовательную кучу. Можно с заменой глобального менеджера, можно без.

Когда процедура заканчивается, память освобождается оптом.

Достигаем:

* нет оверхеда на освобождение памяти
* есть проверка на то, что память особождена вся

== Локализовать память модуля ==

Глобальный менеджер можно переключать при входе в модуль, библиотеку, объект и возвращать старый при выходе.

Это повышает надёжность: порча памяти одного модуля/потока с высокой вероятностью означает проблемы именно в этом модуле/потоке.

Взаимное влияние модулей/потоков друг на друга — снижается.

== Особая память потока ==

???

= Стек =

Стековые переменные в принципе не поддаются контролю.

Их нельзя посмотреть (в отличие от динамических). Брошенные указатели на них не распознаются.

Может быть, имеет смысл завести некий управляемый стековый фрейм? Через завуалированные обращения к спец.менеджеру или через стек, но обёрнутое в спец.объект, поддающийся контролю.

= Типовые проблемы с памятью =

Указатель внутрь разрушенного объекта. Объект может быть стековым или динамическим.

Указатель внутрь освобождённого дин.блока.

Повторное уничтожение блока.

delete по указателю, не указывающему на начало дин.блока (варианты: в середину или вне блока)

Мусорный (неинициализированный) указатель.

Указатель смещаем и вылазим за пределы блока — как назад, так и вперёд.

Ворох проблем со статическими объектами: к ним в принципе можно обратиться до инициализации.

Запись в readonly-память.

???

= Классификация указателей =

Нулевой

Тыкает в начало блока

Тыкает в середину блока

Тыкает в стек некоторого потока

Тыкает в статические данные

Тыкает в image exe/dll/др.файла

Тыкает в другое место, запрошенное у системы

Тыкает в невыделенную память

= Важно

Нужен GUI для мониторинга текущего состояния (с полным просмотром содержимого), сохранения и открытия дампов. Так же он должен работать как отладчик, т.е. пауза/продолжить/прервать процесс.

Надо, чтобы несколько экземпляров библиотеки памяти не конфликтовали и самостоятельно разобрались, кто будет обслуживать глобальный менеджер.

Если в процесс загружено несколько экземпляров библиотеки, в GUI должны показываться всё.

GUI/скрипт, в котором указываешь нужный функционал и он генерирует .h-файл с ним и собирает .dll без лишних соплей. Производительность — наше всё.

При статической линковке можно использовать универсальный .h-файл, подлинкуется только нужное.

Раписать интеграцию с POCO, т.к. там есть свой функционал логгирования и контекстов, как его подключить?

Получится ли сделать сборщик мусора и каким он должен быть и уместен ли он в C++?

Может быть, достаточно сделать его статичным, чтобы в GUI можно было сказать: freeze и пробежаться по всем указателям, которые найдутся в программе.

Профилирование и автоматический подбор типа и параметров оптимального глобального менеджера.

Идентификация объектов сторонними средствами. Т.е. блок можно скармливать сервисами идентификации, может они покажут что-то более подробное.
