
 одировка должна описывать другие кодировки, из которых она может инициализироватьс€:

а) с нулевой конвертацией - код-в-код

б) с полной конвертацией - любой символ другой кодировки может превратитьс€ в символ текущей

в) с частичной конвертацией - некоторые символы другой кодировки можно превратить в текущую, другие - нет


struct EncCvt_Zero {};
struct EncCvt_Full {};
struct EncCvt_Partial {};

Zero считаем разновидностью Full, а Full - разновидностью Partial. “.е. если надо проверить, перекодируетс€
ли код хоть как-то, 

struct BaseEncoding
{
    typedef ??? type;
	typedef ??? encoding;

	Ufast cvt(Ufast from);     // declared Zero & Full types only
	O<Ufast> cvt0(Ufast from); // declared always
};

struct E: public Encoding
{
    typedef ??? baseEncodings; // list of base encodings
};



Char('ы') должен работать только дл€ текущей кодировки CPPDRG_CHAR_ENCODING.

ј т.к. char и int мало чем отличаютс€, считаем, что если вызвали Char(число), это число в кодировке
CPPDRG_CHAR_ENCODING.

CPPDRG_CHAR_ENCODING по замыслу совпадает с кодировкой исходников. ≈сли не задан, неплохо бы уметь
как-то определ€ть его автоматически, из макросов компил€тора, например. ≈сли это возможно.

— другой стороны, надо как-то уметь описывать любые символы, скажем, в ”никоде. ѕоэтому функци€ uc(120)
возвращает символ с заданным уникодом. “ип наверное Char<EncodingUtf32>.
uc = Unicode Character.

ј потом уже он превращаетс€ в нужный.

“ипа так:

Char<EncodingKOI8> c = 75; // 200 - по кодировке KOI8
Char<EncodingKOI8> c = uc(200); // 200 - по ”никоду

¬ обоих случа€х возможны исключени€, если соответствующего кода не существует.
