Интерфейс-реализация: способы воплощения


1. Классика

Классический способ заключается в том, что интерфейс объекта описывается как абстрактный
класс с чистыми виртуальными функциями, реализация описывается в наследнике, реальный
класс создаётся как динамический экземпляр реализации и для доступа к объекту используется
указатель на интерфейсный класс.

Вариант хорошо изучен, используется повсеместно и имеет полное право на жизнь.

Хочу, однако, обратить внимание на следующие недостатки.

DYNONLY. Предполагается обязательное использование динамической памяти, что для мелких объектов
представляется не вполне оправданным оверхедом. Пример: класс цвета пикселя.

LLOSSES. Семантика использования указателя не предполагает неявной инициализации и копирования
объекта. Эти удобные возможности языка - теряются.

LIVECTRL. Вопрос управления жизнью объекта предполагается решать пользователю. Полезная
возможность языка автоматически вызывать деструктор - не используется. Проблема, впрочем,
снимается использованием "умных" указателей.

NULL. Для указателя всегда имеется нулевое "неинициализированное" значение. Невозможно разделить
смыслы "объект точно существует" и "объект может быть, а может не быть". Вопрос опять же
снимается использованием "умных" указателей.

SYNTX. Проблемы синтаксиса: вызов методов через стрелку (вместо точки) более громоздок, для обращения к
операторам требуется явное разыменование, которое неуклюже выглядит и о котором легко забыть,
получая в результате вместо сравнения объектов сравнение указателей.

MULTIMPL. Невозможна замена реализации "на лету", по инициативе самого класса. Пользователь может
заменить реализацию, но чтобы это могла сделать сама реализация, ей потребуется доступ
к указателю, через который к ней обращаются. Причём - ко всем указателям.

SEPIMPL. Все реализации независимы и реализуют полный функционал. Интерфейс декларирует лишь
сигнатуру методов. Невозможно включить в класс часть реализации, сделав другую часть вариабельной.

Часть из перечисленных проблем решается внимательным кодированием, другие создают
лишь проблемы с читабельностью, третьи же - принципиально неразрешимы в рамках "классического" подхода.

Посмотрим, можно ли сделать лучше.

2. Идиома вариабельного хвоста

В реализации класса можно выделить четыре аспекта:
а) тела методов
б) данные, размер которых фиксирован
в) разные, размер которых становится известен при конструировании
г) разные, размер которых меняется в процессе работы

Для примера рассмотрим, данные каких видов нужны для различных реализаци класса текстовой строки.

Реализация, хранящая короткую строку ограниченной длины требует только тип (б) - под максимально
возможное число символов.

Реализация, хранящая строку, задаваемую при конструировании и далее не меняемую, требует тип (б)
под размер строки и тип (в) под символы строки.

Наконец, реализация, хранящая изменяемую строку требует данные типа (б) и (г).

Классический подход предполагает, что в тело класса-реализации включается указатель на таблицу
(виртуальных) методов, данные типа (б) и указатели на данные типа (в) и (г).

Доступ к данным ведётся через указатель this, передаваемый в методы неявным параметром.

Для короткой строки данные такие:

|  ук-ль на MT  |    память под символы    |

Для неизменяемой и неизменяемой строки данные такие:

|  ук-ль на MT  |   длина строки   |  ук-ль на память под символы   |

Видно, что для неизменяемой строки желательна оптимизация:

|  ук-ль на MT  |   длина строки   |  память под символы   |

Лишнее выделение динамической памяти можно исключить без вреда для дела.

Здесь на помощь приходит идиома вариабельного хвоста.

Её особенность в том, что конструирование реализации должно выполнятся спец.фабрикой, конструктора
недостаточно:

struct FixedString
{
	size_t _strLen;

	FixedString(size_t strLen):
		_strLen(strLen)
	{}

	const char* chars() const
	{
		return static_cast<const char*>(static_cast<const void*>(this+1));
	}

	static FixedString* create(size_t strLen)
	{
		char *mem = new char[sizeof(FixedString) + strLen * sizeof(char)];
		return new(mem) FixedString(strLen);
	}
};

Для доступа к данным символов нужно вызывать inline-метод chars(), который прекрасно оптимизируется
и скорость доступа к "хвосту" с символами не отличается по времени от доступа к обычному полю.

Метод всячески рекомендуется к использованию, если размер дополнительных данных (хотя бы некоторых)
известен на стадии конструирования.

Удаление можно вести при помощи обычного оператора delete с одной оговоркой: если дополнительные
данные требуют деструктора, его придётся вызвать вручную.

3. Идиома pimpl

Данная идиома - есть специфический вариант "умного" указателя. Кроме того, что она скрывает
реализацию, он решает практически все проблемы "классического" варианта:
- LLOSSES
- LIVECTRL
- NULL
- SYNTX
- MULTIMPL
- SEPIMPL

Не решено только обязательное использование динамической памяти, проблема DYNONLY.

Эта проблема, однако, весьма существенна.

4. Идиома встроенного хранилища

Идиома pimpl предполагает, что интерфейсный класс хранит только указатель на реализацию.

struct MyClassImpl;
struct MyClass
{
	// интерфейс

private:
	MyClassImpl* _pimpl;
};

Для решения проблемы DYNONLY вполне логично встроить в класс некоторый объём памяти, которым
может пользоваться реализация. Из самой сути класса обычно можно заключить, сколько памяти
разумно выделять статически.


struct MyClassImpl;
struct MyClass
{
	// интерфейс

private:
	char         _storage[12];
	MyClassImpl* _pimpl;
};

struct MyClassImpl
{
	virtual void foo(char (&storage)[12], ...);
};

Указатель на _storage нужно передавать параметром в методы, чтобы они могли использовать данную
память по своему усмотрению.

Структура памяти получается следующая:


|  статическая память   |  ук-ль на реализацию  |
                                    |
 -----------------------------------
|
|  ук-ль на MT  |  поля класса?  |
        |
 -------
|
| ук-ль на метод 1 | ук-ль на метод 2 | ...


Это если предполагается множественность реализаций. Если реализация единственная, указатель на
MT отсутствует, а методы вызываются непосредственно, по статически известным адресам.

Но интересно другое: получается, что есть два места, где класс может хранить свои данные:
- в обычных полях класса, доступных через this
- в _storage, доступный через дополнительно передаваемый указатель

Получается, в каждый метод передаётся два указателя, что представляется явлением сомнительным.

Встают два вопроса: бывают ли случаи, когда два указателя оправданы? И как избавиться от this?

Начнём со второго.

В случае единственной релизации решение совершенно тривиально: нужно сделать все методы
класса-реализации статическими.

Если реализаций множество, нам потребуется где-то хранить указатели на методы. Нет другого выхода,
кроме как реализовать таблицу этих методов вручную и хранить указатель на неё.

Данный ход несколько ухудшает синтаксис вызовов, но избавляет и от указателя на this и от необходимости
выделять лишний ненужный блок динамической памяти. Структура получается такая:

|  статическая память   |  ук-ль на реализацию  |
                                    |
 -----------------------------------
|
| ук-ль на метод 1 | ук-ль на метод 2 | ...


struct MyClassImpl;
struct MyClass
{
	bool doIt(int param)
	{
		return (*_pimpl->doIt)(_storage, param);
	}

private:
	char         _storage[12];
	MyClassImpl* _pimpl;
};

struct MyClassImpl
{
	bool (*doIt)(char (&storage)[12], int param);
};

Эта реализация оптимальна и не содержит ничего лишнего, хоть и несколько громоздка в использовании.

Два указателя на данные представляются явлением, на практике бесполезным. Если памяти в storage
не хватает, туда всегда можно поместить указатель на доп.данные и пользоваться им, по скорости это
то же самое, что передавать this параметром. Зато если данные в storage помещаются, передача this -
это бессмысленные накладные расходы.

Никаких иных разумных причин не просматривается.

Итак, если мы используем хранение данных прямо в классе-интерфейсе, оптимальное решение для
множественных реализаций есть прямой указатель на таблицу указателей на методы.

Как же её заполнять?

5. Заполнение таблицы методов

Первый и очевидный вариант: каждой реализации сопоставить свою собственную статическую таблицу,
заполняемую статически:

bool doIt(char (&storage)[12], int param)
{
	// реализация
}

struct Impl1: public MyClassImpl
{
	Impl1()
	{
		_doIt = &doIt;
	}

	static Impl1 object; // синглтон
};


Вариант хорошо и быстро работает. Фактически, это ручной аналог генерируемой компилятором
таблицы виртуальных методов (VMT).

По сравнению с VMT ручная реализации имеет серьёзные бонусы:

а) есть возможность оставить часть указателей неинициализированными (нулевыми), удобно для
опциональной функциональности; в классической VMT такое требует или специального возвращаемого
значения или специального метода "расскажи, что эта реализация поддерживает"

б) кроме методов, туда можно положить иную информацию статического характера

Есть небольшой недостаток: неудобный синтаксис вызова.

И есть большой недостаток: если класс является шаблоном, такая реализация не годится совершенно.

Почему? Покажем на примере.

template<class Class>
struct MyClassImpl;

template<class Class>
struct MyClass
{
	bool doIt(Class param)
	{
		return (*_pimpl->doIt)(_storage, param);
	}

private:
	char               _storage[12];
	MyClassImpl<Class>* _pimpl;
};


Чем инициализировать _pimpl? В нешаблонном классе мы туда клали указатель на глобальную переменную,
инициализируемую при загрузке программы (Impl1::object).

Здесь же реализация зависит от шаблонного параметра и реализаций должно быть столько, сколько пользователь
класса придумал вариантов использования. Понятно, что глобальные переменные здесь не подходят.

Создавать по экземпляру MyClassImpl<Class> на каждый объект так же не годится - накладно.

Выхода видится три:

а. Создавать некоторый реестр реализаций, при создании объекта искать в нём готовый MyClassImpl,
при отсутствии - создавать динамически. Поиск в реестре неопределённого размера, вызываемый в каждом
конструкторе выглядит крайне сомнительной идеей. Годится разве что для случаев, когда объектов
класса MyClass гарантированно мало.

б. Отказаться от шаблонности в реализации, а все аспекты шаблоности передавать параметрами.

в. Вернуться к стандартным VMT, которые компилятор умеет генерировать автоматически: избегая
дублирования и генерируя их ровно столько, сколько нужно. Этот ход требует хака, безопасность которого,
впрочем, легко проверяется.

Остановимся на вариантах (б) и (в) подробнее.

Из того, что класс шаблонный вовсе не следует, что шаблонной должна быть и реализация. Рассмотрим
классический шаблон - контейнер.

template<class Item>
struct Container
{
	Container();
	Item& operator[](size_t index);

private:
	char           _storage[12];
	ContainerImpl* _pimpl;
};

struct ContainerImpl
{
	void (*createNew)(char (&storage)[12]);
	void* (*getByIndex)(char (&storage)[12], size_t index, size_t itemSize);
};

template<class Item>
Container<Item>::Container():
	_pimpl(&/*глобальная переменная с релизацией*/)
{
	(*_pimpl->createNew)(_storage);
}

template<class Item>
Item& Container<Item>::operator[](size_t index)
{
	void* ret = (*_pimpl->getByIndex)(_storage, index, sizeof(Item));
	return static_cast<Item*>(ret);
}

Обратите внимание на реализацию operator[]. Чтобы вернуть указатель на элемент, реализации не нужно
знать его класс, достаточно знать размер объекта, передаваемый явно. Возвращаемое значение
может быть void*, преобразуемое к нужному типу.

Это вполне нормальный вариант для немалого числа случаев.

Следует отметить потерю производительности. Здесь у нас только передаётся только размер элемента,
а в более сложных случаях потребуется передавать ссылки на callback-функции, которые реализация
будет вызывать, чтобы обратиться к функциональности шаблона. В примере с контейнером, если захочется
его отсортировать, придётся передать указатель на функцию сравнения элементов.

Ещё важнее то, что в ряде случаев шаблонность принципиально неустранима: например, когда реализация
отвечает за преобразование типов.

Тогда можно оставить реализацию шаблонной и воспользоваться хаком:

template<class Item>
struct Container
{
	Container();
	Item& operator[](size_t index);
	void sort();

private:
	ContainerImpl<Impl> _impl;
};

struct ContainerImpl
{
	virtual void createNew() = 0;
	virtual getByIndex(size_t index) = 0;
	virtual sort() = 0;

	char _storage[12];
};


Код выглядит крамольно и, разумеется, не компилируется, поскольку требует инстанцирования
абстрактного класса.

Но в чём замысел?

Замысел в том, чтобы дать всем реализациям общий объём фиксированной памяти и размещать
объект-реализацию прямо внутри интерфейсного класса. При этом реализация может быть
шаблонной - о создании VMT под нужные типы позаботится компилятор.

Главное требование к реализациям - не добавлять своих данных, а только реализовывать
виртуальные методы. Тогда можно ожидать, что размер объекта не изменится - что и происходит
на всех мне известных компиляторах.

Приведём компилируемый код:

template<class Item>
struct ContainerImpl
{
	virtual Item& getByIndex(size_t index) = 0;
	virtual sort() = 0;

	char _storage[12];
};

template<class Item>
struct Container
{
	Container();
	Item& operator[](size_t index);
	void sort();

private:
	char _impl[sizeof(ContainerImpl<Item>)];
	ContainerImpl<Item>& impl()
	{
		return *static_cast<ContainerImpl<Item>*>(static_cast<void*>(_impl));
	}
};


template<class Item>
Container<Item>::Container()
{
	new(_impl) Impl1();
}

template<class Item>
Item& Container<Item>::operator[](size_t index)
{
	return impl().getByIndex(index);
}

template<class Item>
Item& Container<Item>::sort()
{
	return impl().sort();
}


Решение можно считать идеальным, если бы не хак. Вызов impl() прекрасно оптимизируется, не внося
потерь производительности.

Синтаксис работы - удобный. Реализацию писать относительно просто. Шаблоны поддерживаются.

Поэтому данный вариант я рекомендую для использования во всех случаях, когда требуется встроить
хранилище данных в интерфейсный класс, независимо от того, шаблонный класс или нет.




Резюме я бы подвёл такое.

Для pimpl реализация должна уметь выбираться в конструкторе.

Если это так, лучше юзать его, чем "классический" подход с указателями.

Если реализация одна, ...

Если реализаций несколько, надо делать выбор:
- простой указатель на реализацию - все данные в дин.памяти
- хак со встраиваемой реализацией - часть данных интегрирована

В обоих случаях, таблицу методов можно реализовать вручную, а можно - автоматически.

Итого - четыре варианта.

Так же в случае шаблонного интерфейса, следует выбрать: делаем ли мы реализацию так же шаблонной?
Вполне разумный вариант сделать две реализации: в одну сунуть нешаблонную часть,

Ручную таблицу надо выбирать, если хочется в статические данные воткнуть что-то помимо методов
или сделать методы опциональными.

Но если реализация шаблонна, иного варианта, кроме как автоматическая таблица - нет. Придётся
отказаться от ручной и реализовать всё дополнительное через вызовы методов.

Такие дела.
